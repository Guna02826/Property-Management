# Neorem - Property Management MVP - Technical Plan

## 1. Technology Stack

### Frontend
- **Framework**: React 18+ with TypeScript
- **Meta-framework**: Next.js 14+ (App Router) for SSR/SSG and API routes
- **Styling**: Tailwind CSS with shadcn/ui components
- **State Management**: TanStack Query (React Query) for server state, Zustand for client state
- **Forms**: React Hook Form with Zod validation
- **Maps**: Google Maps JavaScript API (if property mapping required)
- **Platform**: Web application only (responsive design)

**Rationale**: Next.js provides excellent DX, built-in optimizations, and API route capabilities. TanStack Query handles caching and synchronization elegantly. Tailwind enables rapid UI development with consistent design system. Web-only approach reduces development complexity and maintenance overhead.

### Backend
- **Runtime**: Node.js 20 LTS
- **Framework**: Fastify (high-performance, plugin-based architecture)
- **ORM**: Sequelize exclusively
- **Database**: PostgreSQL 15+ (Cloud SQL on GCP)
- **Cache**: Redis 7+ (Memorystore on GCP) for caching
- **Queue Processing**: Google Cloud Tasks and Pub/Sub for async job processing
- **API Style**: REST-first with WebSocket support for real-time features
- **Dynamic Schema Support**: Dynamic database field handling via query parameters and request params, enabling schema changes without API modifications

**Rationale**: Fastify provides excellent performance and a plugin-based architecture that scales well. Sequelize offers mature ORM capabilities with strong PostgreSQL support and migration tooling. GCP Cloud Tasks and Pub/Sub provide managed queue processing without infrastructure management. Dynamic schema support enables flexible data model evolution without requiring API code changes.

### Authentication & Authorization
- **Provider**: Auth0 (OIDC/OAuth2)
- **Token Format**: JWT (RS256) with refresh token rotation
- **Implementation**: Auth0 SDK for frontend, JWT verification middleware in Fastify
- **Role Management**: Custom roles stored in database, claims in JWT token

**Rationale**: Auth0 handles user management, password reset, MFA, and social logins out of the box, reducing development time and security burden.

### File Storage
- **Primary**: Google Cloud Storage (GCS) with signed URLs for direct client uploads
- **CDN**: Cloudflare for asset delivery and DDoS protection
- **Implementation**: Google Cloud Storage client library, signed URL generation for secure uploads

**Rationale**: GCS provides scalable, durable storage with fine-grained access control. Signed URLs enable secure direct uploads without proxying through backend. Cloudflare provides global CDN with excellent performance and security features. GCS is the exclusive cloud storage solution.

### Messaging & Notifications
- **Email**: Google Cloud SendGrid API or Gmail API (via GCP)
- **Push Notifications**: Web Push API (browser) with service worker
- **Queue Processing**: Google Cloud Tasks and Pub/Sub for async notification processing

**Rationale**: GCP-managed email services provide cost-effective email delivery with high deliverability. Cloud Tasks and Pub/Sub enable reliable async processing with automatic retries and dead letter queues.

### Payment Tracking & E-Signature (Placeholders)
- **Payment Tracking**: Manual entry and import of payment records
- **E-Signature**: DocuSign API (stub interfaces initially, full integration later)
- **Implementation**: Payment records stored in database, DocuSign webhooks for signature completion

**Rationale**: Payment tracking only - users track payments made through external systems. DocuSign is industry standard for legal document signing.

### Hosting & Infrastructure
- **Compute**: Google Cloud Run (containerized Fastify) or Cloud Functions (serverless option for future)
- **Database**: Google Cloud SQL PostgreSQL (High Availability for production)
- **Cache**: Google Cloud Memorystore Redis
- **Storage**: Google Cloud Storage (GCS)
- **Load Balancing**: Google Cloud Load Balancer with Cloud Armor (WAF)
- **CDN**: Cloudflare for static assets and API caching
- **DNS**: Cloudflare DNS
- **Queue Services**: Google Cloud Tasks and Pub/Sub
- **Monitoring**: Google Cloud Operations (formerly Stackdriver) with Cloud Trace

**Rationale**: GCP provides comprehensive managed services, reducing operational overhead. Cloud Run enables containerized deployments with automatic scaling. Cloudflare provides global CDN and DDoS protection.

---

## 2. Architecture & Non-Functional Requirements

### High-Level Architecture

```
┌─────────────────┐
│   Next.js App   │ (Frontend + API Routes)
│  (Cloudflare)   │
└────────┬────────┘
         │ HTTPS
         ▼
┌─────────────────┐
│   Load Balancer │ (GCP LB + Cloud Armor)
│   / API Gateway │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Fastify Services│ (Cloud Run)
│  (Stateless)    │
└────────┬────────┘
         │
    ┌────┴────┬──────────┬──────────┬──────────┐
    ▼         ▼          ▼          ▼          ▼
┌────────┐ ┌──────┐  ┌──────┐  ┌──────────┐ ┌────────┐
│Postgres│ │Redis │  │ GCS  │  │Cloud Tasks│ │Pub/Sub │
│(Cloud  │ │Cache │  │Files │  │  Queues  │ │Events  │
│  SQL)  │ │      │  │      │  │          │ │        │
└────────┘ └──────┘  └──────┘  └──────────┘ └────────┘
```

### Multi-Tenant Approach
- **Strategy**: Row-level multi-tenancy with `tenant_id` (organization_id) on all tenant-scoped tables
- **Isolation**: Database-level row-level security (RLS) policies on critical tables
- **Enforcement**: Middleware/hooks in Fastify services ensuring tenant_id is set and validated on all queries
- **Super Admin**: Separate admin schema/tenant for platform operations

**Implementation**:
- All tenant data tables include `organization_id` column
- Sequelize hooks and scopes automatically filter queries by tenant_id from JWT claims
- Database RLS policies as defense-in-depth for critical financial tables
- Tenant context injected via Fastify hooks/decorators

### Security
- **Authentication**: OAuth2/OIDC via Auth0, JWT tokens with RS256 signature
- **Authorization**: Role-based access control (RBAC) with tenant-scoped permissions
- **Data Encryption**: TLS 1.3 in transit, encryption at rest for Cloud SQL and GCS
- **Input Validation**: Zod schemas for all API inputs, Sequelize model validation
- **SQL Injection Prevention**: Sequelize parameterized queries
- **XSS Prevention**: React's built-in escaping, Content Security Policy headers
- **CSRF Protection**: SameSite cookies, CSRF tokens for state-changing operations
- **Rate Limiting**: Per-tenant and per-IP rate limits at API gateway level
- **Secrets**: Google Secret Manager for API keys, database credentials, JWT secrets

### Audit Logging
- **Table**: `audit_logs` with columns: `id`, `tenant_id`, `user_id`, `resource_type`, `resource_id`, `action`, `before_state`, `after_state`, `ip_address`, `user_agent`, `timestamp`
- **Logging Events**: All CREATE, UPDATE, DELETE operations on critical entities (leases, payments, maintenance requests)
- **Storage**: Append-only table, periodic archival to GCS after 12 months
- **Query Performance**: Partitioned by month, indexed on `tenant_id`, `resource_type`, `timestamp`

### Secrets Management
- **Primary**: Google Secret Manager for sensitive credentials (DB passwords, API keys)
- **Configuration**: Google Cloud Runtime Config for non-sensitive config
- **Rotation**: Automated rotation for Cloud SQL credentials via Secret Manager
- **Access**: IAM roles with least-privilege policies, no secrets in environment variables or code

### Performance Targets
- **API Latency**: p95 < 300ms for standard CRUD operations, p95 < 150ms for cached reads
- **File Upload**: Presigned URL generation < 150ms
- **Page Load**: First Contentful Paint < 1.5s, Time to Interactive < 3s
- **Uptime**: 99.5% availability (MVP target), 99.9% for production
- **Database**: Query execution < 100ms for indexed queries, < 500ms for complex reports

### Scalability Approach
- **Horizontal Scaling**: Stateless API services behind load balancer, auto-scale based on CPU/memory metrics
- **Database Scaling**: Read replicas for reporting queries, connection pooling (PgBouncer)
- **Caching Strategy**: Redis (Memorystore) for frequently accessed data (property details, user sessions), CDN caching for static assets
- **Queue Processing**: Cloud Tasks and Pub/Sub with automatic scaling based on queue depth
- **Future Considerations**: Database sharding by tenant_id if single-tenant data exceeds 100GB

### Backups & Disaster Recovery
- **Database Backups**: Cloud SQL automated daily backups with 7-day retention (extend to 14 days for production), point-in-time recovery enabled
- **File Storage**: GCS versioning enabled, lifecycle policies for cost optimization
- **Backup Testing**: Monthly restore drills to verify backup integrity
- **Disaster Recovery**: High Availability deployment for Cloud SQL, cross-region backup replication for critical data
- **RTO/RPO**: Recovery Time Objective < 4 hours, Recovery Point Objective < 1 hour

---

## 3. Database Schema Notes

### Core Tables Confirmed
Based on existing schema documentation, the following core tables are defined:
- `organizations` (multi-tenant root)
- `users` (with organization_id)
- `roles` and `user_roles` (RBAC)
- `properties`, `units`, `buildings` (property hierarchy)
- `leases`, `lease_terms`, `lease_tenants` (lease management)
- `payments`, `payment_schedules`, `invoices` (financial)
- `maintenance_requests`, `work_orders` (maintenance)
- `documents` (file metadata)
- `messages`, `notifications` (communication)
- `audit_logs` (audit trail)

### Key Indexes
- **Multi-tenant isolation**: `(organization_id)` index on all tenant-scoped tables
- **User lookup**: `(organization_id, email)` unique index on `users`
- **Property queries**: `(organization_id, property_id)` on `units`, `leases`
- **Maintenance filtering**: `(organization_id, status, created_at DESC)` on `maintenance_requests`
- **Payment queries**: `(organization_id, lease_id, due_date)` on `payments`
- **Audit queries**: `(organization_id, resource_type, timestamp DESC)` on `audit_logs`
- **Full-text search**: GIN indexes on `name`, `description` fields if text search required

### Partitioning & Archival Strategy
- **Partitioning**: Time-based partitioning on `audit_logs` by month (enables efficient archival)
- **Archival**: Move audit logs older than 12 months to GCS (Parquet format), retain metadata in database
- **Considerations**: Partition `payments` table by year if volume exceeds 1M rows per tenant
- **Retention**: Financial data retained for 7 years (compliance), audit logs for 3 years active, then archived

### Migration Strategy
- **Tool**: Sequelize Migrations for schema changes
- **Environments**: 
  - `dev`: Auto-apply migrations on deployment
  - `stage`: Manual approval required, test migration rollback
  - `prod`: Manual approval + maintenance window, verified rollback plan
- **Rollback Plan**: 
  - All migrations must be reversible (down migrations provided)
  - For destructive changes: expand-contract pattern (add new column, migrate data, remove old column in separate migrations)
  - Feature flags for schema-dependent features to enable gradual rollout
- **Versioning**: Semantic versioning of schema migrations, tagged releases

### Dynamic Schema Support
- **Approach**: Dynamic field handling via query parameters and request body parameters
- **Implementation**: 
  - API endpoints accept dynamic field names as query parameters or in request body
  - Database queries constructed dynamically based on provided field names
  - Field validation performed at runtime using schema metadata
  - No API code changes required when new database fields are added
  - Frontend can request any fields via query params: `?fields=field1,field2,field3`
  - Backend dynamically constructs SELECT queries based on requested fields
- **Benefits**: 
  - Schema evolution without API versioning
  - Flexible data retrieval based on client needs
  - Reduced deployment cycles for schema changes
- **Limitations**: 
  - Security: Field access still enforced via RBAC
  - Performance: Dynamic queries may require additional indexing considerations
  - Validation: New fields must be added to validation schemas

### Parent-Child Relationship Deletion Behavior
- **Detach Child**: When deleting a child entity, parent relationship is detached (parent_id set to NULL) rather than cascading deletion
- **Cascade Delete**: When deleting a parent entity, option to delete all children or detach them based on business rules
- **Implementation**:
  - Portfolio → Property: Deleting portfolio detaches properties (property.portfolio_id = NULL) unless cascade explicitly requested
  - Property → Unit: Deleting property detaches units (unit.property_id = NULL) unless cascade explicitly requested
  - Unit → Lease: Deleting unit requires explicit confirmation for lease handling (cannot delete unit with active lease)
  - Soft delete with recycle bin: All deletions are soft deletes (deleted_at timestamp), allowing recovery
  - Permanent deletion: Only Super Admin can permanently delete from recycle bin
- **Recycle Bin**:
  - All deleted records stored with deleted_at timestamp
  - Super Admin can restore or permanently delete from recycle bin
  - Automatic cleanup policies for records older than retention period (configurable per entity type)

---

## 4. API Design

### Authentication Approach
- **Protocol**: OAuth2/OIDC with JWT bearer tokens
- **Flow**: Authorization Code flow with PKCE (frontend), Client Credentials for service-to-service
- **Token Storage**: HTTP-only cookies for refresh tokens, memory storage for access tokens (frontend)
- **Token Validation**: RS256 signature verification, issuer validation, expiration checks
- **Refresh**: Automatic token refresh via refresh token rotation (30-day expiry, 7-day sliding window)

### API Versioning
- **Strategy**: URL path versioning (`/v1/`, `/v2/`)
- **Deprecation**: Minimum 6-month notice for deprecated versions, sunset headers in responses
- **Breaking Changes**: New major version required (increment to `/v2/`)

### Pagination & Filtering Conventions
- **Pagination**: Cursor-based pagination (preferred) or offset-based for simple cases
  - Query params: `limit` (default: 20, max: 100), `cursor` (opaque token)
  - Response: `{ data: [], pagination: { cursor, hasMore, total } }`
- **Filtering**: Query parameter format: `filter[field]=value&filter[status]=active`
- **Sorting**: `sort=field.asc` or `sort=field.desc`, multiple fields: `sort=created_at.desc,name.asc`
- **Search**: `search=query` for full-text search on name/description fields

### Error Format
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid input provided",
    "details": [
      {
        "field": "email",
        "message": "Email format is invalid"
      }
    ],
    "requestId": "req_abc123",
    "timestamp": "2025-01-12T10:30:00Z"
  }
}
```
- **HTTP Status Codes**: 400 (Bad Request), 401 (Unauthorized), 403 (Forbidden), 404 (Not Found), 409 (Conflict), 422 (Unprocessable Entity), 500 (Internal Server Error)
- **Error Codes**: Machine-readable codes (e.g., `VALIDATION_ERROR`, `RESOURCE_NOT_FOUND`, `TENANT_MISMATCH`)

### Core REST Endpoints

#### Authentication & User Management
- `GET /v1/me` - Get current user profile (Bearer token required)
- `GET /v1/tenants` - List user's accessible tenants/organizations (Bearer token required)
- `POST /v1/users/invite` - Invite user to tenant (Bearer token, Admin role required)

#### Properties & Units
- `GET /v1/properties` - List properties (Bearer token, tenant-scoped, supports pagination/filtering)
- `POST /v1/properties` - Create property (Bearer token, Manager+ role required)
- `GET /v1/properties/:id` - Get property details (Bearer token, tenant-scoped)
- `PUT /v1/properties/:id` - Update property (Bearer token, Manager+ role required)
- `GET /v1/properties/:id/units` - List units for property (Bearer token, tenant-scoped)
- `POST /v1/properties/:id/units` - Create unit (Bearer token, Manager+ role required)

#### Leases
- `GET /v1/leases` - List leases (Bearer token, tenant-scoped, filterable by property/unit/status)
- `POST /v1/leases` - Create lease (Bearer token, Manager+ role required)
- `GET /v1/leases/:id` - Get lease details (Bearer token, tenant-scoped)
- `PUT /v1/leases/:id` - Update lease (Bearer token, Manager+ role required)
- `POST /v1/leases/:id/sign` - Initiate e-signature (Bearer token, Manager+ role, DocuSign integration)
- `GET /v1/leases/:id/documents` - List lease documents (Bearer token, tenant-scoped)

#### Payment Tracking
- `POST /v1/payments` - Create payment record (Bearer token, Manager+ role required, manual entry)
- `POST /v1/payments/import` - Import payment records (Bearer token, Manager+ role required, CSV/JSON import)
- `GET /v1/payments` - List payments (Bearer token, tenant-scoped, filterable by lease/status)
- `GET /v1/payments/:id` - Get payment details (Bearer token, tenant-scoped)
- `PUT /v1/payments/:id` - Update payment record (Bearer token, Manager+ role required)
- `POST /v1/invoices` - Generate invoice (Bearer token, Manager+ role required)

#### Maintenance
- `GET /v1/maintenance` - List maintenance requests (Bearer token, tenant-scoped, filterable by property/status)
- `POST /v1/maintenance` - Create maintenance request (Bearer token, any authenticated user)
- `GET /v1/maintenance/:id` - Get maintenance request details (Bearer token, tenant-scoped)
- `PUT /v1/maintenance/:id` - Update maintenance request (Bearer token, Manager+ role required)
- `POST /v1/maintenance/:id/assign` - Assign work order (Bearer token, Manager+ role required)
- `POST /v1/maintenance/:id/close` - Close maintenance request (Bearer token, Manager+ role required)

#### Documents
- `POST /v1/documents/presign` - Generate presigned upload URL (Bearer token, tenant-scoped)
- `GET /v1/documents/:id` - Get document metadata (Bearer token, tenant-scoped)
- `GET /v1/documents/:id/download` - Get presigned download URL (Bearer token, tenant-scoped)

#### Notifications
- `POST /v1/notifications/test` - Send test notification (Bearer token, Admin role, for testing integrations)
- `GET /v1/notifications` - List user notifications (Bearer token, user-scoped)

### Request/Response Patterns
- **Request Headers**: `Authorization: Bearer <token>`, `Content-Type: application/json`
- **Response Headers**: `Content-Type: application/json`, `X-Request-ID` (for tracing)
- **Idempotency**: POST endpoints accept `Idempotency-Key` header for safe retries
- **Resource Representation**: All resources include `id`, `tenant_id`, `created_at`, `updated_at` fields
- **Nested Resources**: Include related resources via `?include=property,units` query parameter (JSON:API style)

### Webhooks
**Key Events** (configurable per tenant, HMAC-signed):
- `payment.recorded` - Payment record created or updated
- `lease.signed` - Lease document fully signed via DocuSign
- `lease.invitation_sent` - Lease signing invitation sent
- `maintenance.created` - New maintenance request created
- `maintenance.status_changed` - Maintenance request status updated
- `work_order.assigned` - Work order assigned to vendor

**Webhook Format**:
```json
{
  "event": "payment.recorded",
  "tenant_id": "org_123",
  "timestamp": "2025-01-12T10:30:00Z",
  "data": {
    "payment_id": "pay_abc",
    "lease_id": "lease_xyz",
    "amount": 1500.00,
    "status": "recorded"
  }
}
```

**Security**: HMAC-SHA256 signature in `X-Webhook-Signature` header, signature verification required

### Rate Limiting & Throttling
- **Strategy**: Token bucket algorithm per tenant + per IP address
- **Limits**: 
  - Authenticated users: 100 requests/minute per tenant (burst: 200)
  - Unauthenticated: 10 requests/minute per IP (burst: 20)
  - Auth endpoints: 5 requests/minute per IP (prevent brute force)
- **Headers**: `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`
- **Response**: 429 Too Many Requests with `Retry-After` header
- **Webhook Retries**: Exponential backoff (1s, 2s, 4s, 8s, 16s), max 5 retries, dead letter queue after failure

---

## 5. Environments & DevOps

### Environments
- **Development (dev)**: Shared environment for active development, auto-deploy from `main` branch
- **Staging (stage)**: Pre-production environment, mirrors production config, manual deploy approval
- **Production (prod)**: Live environment, manual deploy approval + maintenance window for migrations

**Environment Variables**: Managed via Google Cloud Runtime Config, different parameter paths per environment (`/app/dev/`, `/app/stage/`, `/app/prod/`)

### CI/CD Approach
- **Pipeline**: GitHub Actions
- **Workflow**:
  1. Lint and format check (ESLint, Prettier)
  2. Type checking (TypeScript)
  3. Unit tests (Jest/Vitest)
  4. Integration tests (API + database)
  5. Security scanning (Snyk, npm audit)
  6. Build Docker images
  7. Deploy to dev (auto) / stage (manual approval) / prod (manual approval)
- **Database Migrations**: Run as separate job before application deployment, with rollback capability
- **Feature Flags**: LaunchDarkly or custom implementation for gradual feature rollout

### Testing Levels
- **Unit Tests**: 
  - Coverage target: 80% for business logic, 60% overall
  - Framework: Jest or Vitest
  - Focus: Service layer, utility functions, validation logic
- **Integration Tests**:
  - Framework: Jest with test database (Docker Compose)
  - Focus: API endpoints, database queries, external service integrations (mocked)
  - Run against real database schema (migrations applied)
- **End-to-End Tests**:
  - Framework: Playwright or Cypress
  - Coverage: Critical user flows (login, create property, create lease, payment flow)
  - Run in staging environment before production deploy
- **Contract Tests**: Pact or similar for webhook/payment provider integrations

### Lint & Format
- **Linting**: ESLint with TypeScript plugin, strict rules enabled
- **Formatting**: Prettier with consistent config (2-space indent, single quotes, trailing commas)
- **Pre-commit**: Husky + lint-staged to run linter/formatter on staged files
- **CI Enforcement**: Pipeline fails if lint/format checks fail

### Observability

#### Logging
- **Format**: Structured JSON logs
- **Levels**: ERROR, WARN, INFO, DEBUG
- **Fields**: `timestamp`, `level`, `message`, `tenant_id`, `user_id`, `request_id`, `error` (if applicable)
- **Aggregation**: Google Cloud Logging with Log Explorer for querying (GCP-only, no external logging services)
- **Retention**: 30 days in Cloud Logging, archival to GCS for long-term retention

#### Metrics
- **Collection**: Prometheus-compatible metrics (via OpenTelemetry)
- **Key Metrics**: 
  - Request rate, latency (p50, p95, p99)
  - Error rate (4xx, 5xx)
  - Database query duration, connection pool usage
  - Queue depth, task processing time
  - Business metrics (leases created, payments recorded)
- **Visualization**: Google Cloud Monitoring dashboards (GCP-only)
- **Storage**: Google Cloud Monitoring (Prometheus-compatible)

#### Tracing
- **Tool**: Google Cloud Trace (OpenTelemetry, GCP-only)
- **Coverage**: All API requests, database queries, external API calls
- **Sampling**: 100% for errors, 10% for successful requests (adjustable)
- **Correlation**: Trace IDs propagated to logs and metrics

#### Alerting
- **Channels**: PagerDuty (critical), Slack (warnings), Email (info)
- **Alerts**:
  - Error rate > 1% for 5 minutes
  - p95 latency > 500ms for 10 minutes
  - Database connection pool exhaustion
  - Queue depth > 1000 for 5 minutes
  - Disk space > 80% on Cloud SQL
  - API availability < 99%

**Note**: All monitoring and logging are managed exclusively through Google Cloud Platform (GCP). No external monitoring or logging services are used.

#### Health & Metrics Endpoints
- `GET /healthz` - Basic health check (returns 200 if service is up)
- `GET /healthz/ready` - Readiness check (checks database connectivity)
- `GET /healthz/live` - Liveness check (for Kubernetes/ECS)
- `GET /metrics` - Prometheus metrics endpoint (if using Prometheus)

### Secrets & Config Management
- **Secrets**: Google Secret Manager
  - Database credentials (auto-rotated)
  - API keys (DocuSign, Auth0, Google Maps)
  - JWT signing secrets
- **Configuration**: Google Cloud Runtime Config
  - Feature flags
  - Environment-specific settings (API endpoints, timeouts)
  - Non-sensitive configuration
- **Access**: IAM roles with least-privilege policies, no secrets in code or environment variables
- **Rotation**: Automated rotation for Cloud SQL credentials, manual rotation for API keys (with versioning)

---

## 6. Delivery Plan (Weeks 4-5 Focus)

### Week 1: Foundation & Infrastructure Setup
**Goals**: Finalize technology stack decisions, set up infrastructure scaffolding, initialize repositories

**Tasks**:
- [ ] Finalize and document technology stack choices
- [ ] Set up GCP project and IAM roles
- [ ] Create Terraform project for infrastructure as code
- [ ] Provision development environment (VPC, Cloud SQL PostgreSQL, Memorystore Redis, GCS buckets)
- [ ] Initialize Next.js project with TypeScript, Tailwind, ESLint, Prettier
- [ ] Initialize Fastify project with TypeScript, Sequelize, basic plugin structure
- [ ] Set up GitHub repository with branch protection rules
- [ ] Configure GitHub Actions CI/CD pipeline (lint, test, build stages)
- [ ] Set up Auth0 application and configure OAuth2/OIDC settings
- [ ] Create basic authentication flow (login, token refresh) in frontend and backend

**Deliverables**: 
- Infrastructure code in version control
- Development environment provisioned and accessible
- Basic auth flow working end-to-end
- CI/CD pipeline running successfully

### Week 2: Core Data Model & Multi-Tenancy
**Goals**: Implement database schema, multi-tenant isolation, core entity CRUD operations

**Tasks**:
- [ ] Review and refine database schema based on requirements
- [ ] Create Sequelize models with all core tables (organizations, users, properties, units, leases, etc.)
- [ ] Generate and apply initial migration to dev database
- [ ] Implement multi-tenant hooks/middleware in Fastify (tenant_id injection from JWT)
- [ ] Create Sequelize scopes and hooks for automatic tenant_id filtering
- [ ] Implement database RLS policies for critical tables (if using PostgreSQL RLS)
- [ ] Create seed script for development data (test organizations, users, properties)
- [ ] Implement core CRUD endpoints for Properties (GET, POST, PUT)
- [ ] Implement core CRUD endpoints for Units (GET, POST, PUT)
- [ ] Set up file upload flow (GCS signed URLs, document metadata storage)
- [ ] Configure Cloud Tasks and Pub/Sub for async job processing

**Deliverables**:
- Database schema deployed to dev environment
- Multi-tenant isolation working (users can only access their organization's data)
- Properties and Units CRUD operations functional
- File upload/download working

### Week 3: Lease Management & Integrations Setup
**Goals**: Implement lease management APIs, set up external service integrations (stubs), webhook framework

**Tasks**:
- [ ] Implement Lease CRUD endpoints (GET, POST, PUT)
- [ ] Implement lease-tenant relationship management
- [ ] Create DocuSign integration stub (API client setup, placeholder methods)
- [ ] Implement webhook framework (HMAC signature verification, event routing)
- [ ] Set up email service (SendGrid or Gmail API via GCP) for email sending (test emails working)
- [ ] Create notification service (email/push) with Cloud Tasks workers
- [ ] Implement basic notification sending (test endpoint)
- [ ] Create maintenance request CRUD endpoints (GET, POST, PUT)
- [ ] Implement work order assignment logic

**Deliverables**:
- Lease management APIs functional
- External service integrations configured (test mode)
- Webhook framework ready for event handling
- Notification system sending emails successfully

### Week 4: Payment Tracking & Advanced Features
**Goals**: Implement payment tracking, complete maintenance workflows, audit logging, API standardization

**Tasks**:
- [ ] Implement payment record CRUD endpoints (POST, GET, PUT for manual entry)
- [ ] Implement payment import endpoint (CSV/JSON import)
- [ ] Create payment record storage and retrieval endpoints
- [ ] Implement invoice generation logic
- [ ] Complete maintenance request workflow (assign, update status, close)
- [ ] Implement audit logging middleware (log all mutations to audit_logs table)
- [ ] Standardize pagination across all list endpoints (cursor-based)
- [ ] Implement filtering and sorting across all list endpoints
- [ ] Set up staging environment (infrastructure + deployment)
- [ ] Deploy to staging and run integration test suite
- [ ] Performance testing baseline (identify slow queries, add indexes)

**Deliverables**:
- Payment tracking working end-to-end (manual entry and import)
- Maintenance workflows complete
- Audit logging capturing all mutations
- All APIs support pagination/filtering/sorting
- Staging environment operational

### Week 5: Hardening & Production Readiness
**Goals**: Security hardening, performance optimization, monitoring setup, production deployment preparation

**Tasks**:
- [ ] Implement rate limiting (per tenant, per IP) at API gateway/middleware level
- [ ] Configure WAF rules (SQL injection, XSS protection)
- [ ] Set up caching for frequently accessed data (property details, user profiles)
- [ ] Optimize database queries (add missing indexes, query optimization)
- [ ] Load testing (identify bottlenecks, optimize hot paths)
- [ ] Set up comprehensive monitoring (Google Cloud Monitoring dashboards, alerts)
- [ ] Configure log aggregation and retention policies
- [ ] Test backup and restore procedures (Cloud SQL snapshot restore)
- [ ] Write end-to-end tests for critical user flows
- [ ] Security audit (dependency scanning, penetration testing basics)
- [ ] Create production deployment runbook
- [ ] Set up production environment (infrastructure)
- [ ] Production deployment checklist and approval process

**Deliverables**:
- Rate limiting and WAF configured
- Performance targets met (p95 latency < 300ms)
- Monitoring and alerting operational
- Backup/restore procedures tested and documented
- End-to-end tests passing
- Production environment ready for deployment
- Deployment runbook completed

---

## Appendix: Key Decisions & Rationale

### Why Fastify over Express/NestJS?
- Superior performance (2-3x faster than Express in benchmarks)
- Plugin-based architecture enables modular, reusable code
- Built-in schema validation with JSON Schema
- TypeScript support with excellent type inference
- Lower memory footprint and faster startup time

### Why Sequelize over Prisma?
- Mature ORM with extensive PostgreSQL feature support
- Flexible query building for complex scenarios
- Excellent migration tooling with rollback support
- Strong community and extensive documentation
- Well-tested in production environments

### Why Auth0 over custom auth?
- Reduces security risk (password hashing, MFA, social logins handled)
- Faster time to market
- Compliance features (SOC 2, GDPR) built-in
- User management UI provided

### Why GCP over alternatives?
- Comprehensive managed services reduce operational overhead
- Strong security and compliance certifications
- Global infrastructure for future scaling
- Cost-effective for MVP (pay-as-you-go)
- Excellent integration between services (Cloud SQL, Memorystore, Cloud Tasks, Pub/Sub)
- Cloud Run provides serverless container deployment with automatic scaling

### Why Cloudflare CDN?
- Global edge network with excellent performance
- Built-in DDoS protection and WAF
- Cost-effective pricing model
- Easy integration with any origin (GCP services)

### Why Payment Tracking Only?
- Reduces compliance burden (PCI-DSS not required)
- Faster time to market
- Users can track payments from any source (bank transfers, checks, external systems)
- Simpler architecture and fewer failure points

### Why Cursor-based Pagination?
- Consistent performance regardless of offset
- Better for real-time data
- Industry standard for modern APIs

### AI Recommendations Implementation
- **Approach**: Vector matching using embeddings
- **Technology**: Pre-trained embedding models (e.g., OpenAI embeddings, sentence-transformers) for similarity matching
- **Use Cases**:
  - Property recommendations based on client preferences and search history
  - Vendor recommendations based on service category and performance history
  - Lease renewal suggestions based on market trends and tenant history
  - Maintenance triage suggestions based on request descriptions
- **Implementation**:
  - Embed property features, client preferences, and historical data into vector space
  - Use cosine similarity for matching and ranking
  - Store embeddings in PostgreSQL with vector extension (pgvector) or Redis for fast similarity search
  - No training of custom AI models required
  - Leverages existing pre-trained models for embeddings
- **Benefits**:
  - Fast similarity search and recommendations
  - No model training infrastructure required
  - Cost-effective and scalable
  - Easy to update as data changes

### Highly Configurable Role System
- **Flexibility**: Role system adapts to company size and structure
- **Small Companies**: May have only Owners with full access
- **Medium Companies**: Owners + Managers with property-specific access
- **Large Companies**: Multiple Managers, Assistant Managers, Sales Reps with granular permissions
- **Implementation**:
  - Custom roles can be created per organization
  - Permission sets are configurable and assignable
  - Role hierarchy and inheritance support
  - Property and portfolio-level access control
  - Dynamic role assignment based on organizational needs

